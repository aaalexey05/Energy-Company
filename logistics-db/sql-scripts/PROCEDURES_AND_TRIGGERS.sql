-- ═══════════════════════════════════════════════════════════════════════════════
-- ХРАНИМЫЕ ПРОЦЕДУРЫ И ТРИГГЕРЫ ДЛЯ АВТОМАТИЧЕСКОЙ ОБРАБОТКИ СТАТУСОВ
-- Система Управления Логистикой (5NF)
-- PostgreSQL 16+
-- ═══════════════════════════════════════════════════════════════════════════════

\c logistics_5nf;

-- ═══════════════════════════════════════════════════════════════════════════════
-- 1. ТАБЛИЦА РАЗРЕШЁННЫХ ПЕРЕХОДОВ СТАТУСОВ
-- ═══════════════════════════════════════════════════════════════════════════════

CREATE TABLE IF NOT EXISTS статусы_переходы (
    ид_переход SERIAL PRIMARY KEY,
    ид_статус_от INTEGER NOT NULL REFERENCES статусы_заказов(ид_статус),
    ид_статус_в INTEGER NOT NULL REFERENCES статусы_заказов(ид_статус),
    автоматический BOOLEAN DEFAULT FALSE,
    описание TEXT,
    UNIQUE (ид_статус_от, ид_статус_в)
);

COMMENT ON TABLE статусы_переходы IS 'Разрешённые переходы между статусами грузов';

-- Заполняем матрицу разрешённых переходов
INSERT INTO статусы_переходы (ид_статус_от, ид_статус_в, автоматический, описание) VALUES
    -- Из "Новый заказ" (1)
    (1, 2, FALSE, 'Диспетчер принял груз в работу'),
    (1, 7, FALSE, 'Отмена до начала работы'),

    -- Из "Принят в работу" (2)
    (2, 3, FALSE, 'Груз прибыл на склад отправления'),
    (2, 7, FALSE, 'Отмена после принятия'),

    -- Из "На складе отправления" (3)
    (3, 4, TRUE, 'Груз погружен и отправлен (авто при назначении транспорта)'),
    (3, 7, FALSE, 'Отмена до отправки'),

    -- Из "В пути" (4)
    (4, 5, TRUE, 'Груз прибыл на склад назначения (авто при завершении маршрута)'),
    (4, 7, FALSE, 'Отмена во время транспортировки'),

    -- Из "На складе назначения" (5)
    (5, 6, TRUE, 'Груз выдан получателю (авто при завершении перевозки)'),
    (5, 7, FALSE, 'Отмена перед выдачей'),

    -- Из "Доставлен" (6) - финальный статус
    -- (нет переходов)

    -- Из "Отменен" (7) - финальный статус
    -- (нет переходов)

    -- Дополнительные служебные переходы
    (4, 4, FALSE, 'Обновление данных в пути')
ON CONFLICT (ид_статус_от, ид_статус_в) DO NOTHING;

-- ═══════════════════════════════════════════════════════════════════════════════
-- 2. ТАБЛИЦА НАСТРОЕК СТАТУСОВ (вместо хардкода)
-- ═══════════════════════════════════════════════════════════════════════════════

CREATE TABLE IF NOT EXISTS настройки_статусов (
    ключ VARCHAR(50) PRIMARY KEY,
    ид_статус INTEGER NOT NULL REFERENCES статусы_заказов(ид_статус),
    описание TEXT
);

COMMENT ON TABLE настройки_статусов IS 'Центральное хранилище ID ключевых статусов';

INSERT INTO настройки_статусов (ключ, ид_статус, описание) VALUES
    ('новый', 1, 'Груз только создан'),
    ('принят', 2, 'Принят диспетчером'),
    ('на_складе_отправления', 3, 'Ждёт отправки'),
    ('в_пути', 4, 'Транспортируется'),
    ('на_складе_назначения', 5, 'Ждёт получателя'),
    ('доставлен', 6, 'Финальный успешный статус'),
    ('отменен', 7, 'Финальный статус отмены')
ON CONFLICT (ключ) DO NOTHING;

-- ═══════════════════════════════════════════════════════════════════════════════
-- 3. ОСНОВНАЯ ФУНКЦИЯ СМЕНЫ СТАТУСА
-- ═══════════════════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION изменить_статус_груза(
    p_ид_груз INTEGER,
    p_ид_новый_статус INTEGER,
    p_комментарий TEXT DEFAULT NULL,
    p_ид_пользователь INTEGER DEFAULT NULL
)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_старый_статус INTEGER;
    v_название_старого VARCHAR(100);
    v_название_нового VARCHAR(100);
BEGIN
    -- Получаем текущий статус с блокировкой
    SELECT ид_статус
    INTO v_старый_статус
    FROM грузы
    WHERE ид_груз = p_ид_груз
    FOR UPDATE;

    IF v_старый_статус IS NULL THEN
        RAISE EXCEPTION 'Груз с ID % не найден', p_ид_груз;
    END IF;

    -- Если статус не изменился - выходим
    IF v_старый_статус = p_ид_новый_статус THEN
        RAISE NOTICE 'Груз % уже имеет статус %', p_ид_груз, p_ид_новый_статус;
        RETURN;
    END IF;

    -- Проверяем разрешён ли переход
    IF NOT EXISTS (
        SELECT 1
        FROM статусы_переходы
        WHERE ид_статус_от = v_старый_статус
          AND ид_статус_в = p_ид_новый_статус
    ) THEN
        -- Получаем названия для красивой ошибки
        SELECT наименование INTO v_название_старого
        FROM статусы_заказов WHERE ид_статус = v_старый_статус;

        SELECT наименование INTO v_название_нового
        FROM статусы_заказов WHERE ид_статус = p_ид_новый_статус;

        RAISE EXCEPTION 'Запрещён переход статуса "%" → "%" для груза %',
            v_название_старого, v_название_нового, p_ид_груз;
    END IF;

    -- Обновляем статус груза
    UPDATE грузы
    SET ид_статус = p_ид_новый_статус
    WHERE ид_груз = p_ид_груз;

    -- Записываем в историю
    INSERT INTO история_статусов (
        ид_груз,
        ид_статус_старый,
        ид_статус_новый,
        дата_изменения,
        комментарий,
        ид_пользователь
    ) VALUES (
        p_ид_груз,
        v_старый_статус,
        p_ид_новый_статус,
        CURRENT_TIMESTAMP,
        p_комментарий,
        p_ид_пользователь
    );

    -- Логируем
    SELECT наименование INTO v_название_нового
    FROM статусы_заказов WHERE ид_статус = p_ид_новый_статус;

    RAISE NOTICE 'Груз %: статус изменён на "%" (ID: %)', 
        p_ид_груз, v_название_нового, p_ид_новый_статус;
END;
$$;

COMMENT ON FUNCTION изменить_статус_груза IS 'Основная функция для смены статуса груза с валидацией и историей';

-- ═══════════════════════════════════════════════════════════════════════════════
-- 4. ТРИГГЕР: АВТОМАТИЧЕСКАЯ ДАТА ДОСТАВКИ
-- ═══════════════════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION trg_установить_дату_доставки()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_ид_доставлен INTEGER;
BEGIN
    -- Получаем ID статуса "доставлен" из настроек
    SELECT ид_статус INTO v_ид_доставлен
    FROM настройки_статусов
    WHERE ключ = 'доставлен';

    -- Если статус изменился на "доставлен" и даты ещё нет
    IF NEW.ид_статус = v_ид_доставлен 
       AND NEW.дата_фактическая_доставка IS NULL
       AND OLD.ид_статус IS DISTINCT FROM NEW.ид_статус THEN

        NEW.дата_фактическая_доставка := CURRENT_TIMESTAMP;

        RAISE NOTICE 'Груз %: автоматически установлена дата доставки %',
            NEW.ид_груз, NEW.дата_фактическая_доставка;
    END IF;

    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS установить_дату_доставки ON грузы;

CREATE TRIGGER установить_дату_доставки
    BEFORE UPDATE OF ид_статус ON грузы
    FOR EACH ROW
    WHEN (NEW.ид_статус IS DISTINCT FROM OLD.ид_статус)
    EXECUTE FUNCTION trg_установить_дату_доставки();

COMMENT ON TRIGGER установить_дату_доставки ON грузы IS 'Автоматически проставляет дата_фактическая_доставка при статусе "доставлен"';

-- ═══════════════════════════════════════════════════════════════════════════════
-- 5. ТРИГГЕР: ВАЛИДАЦИЯ ПЕРЕХОДОВ СТАТУСОВ
-- ═══════════════════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION trg_валидация_перехода_статуса()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_название_старого VARCHAR(100);
    v_название_нового VARCHAR(100);
BEGIN
    -- Если статус не изменился - пропускаем
    IF NEW.ид_статус = OLD.ид_статус THEN
        RETURN NEW;
    END IF;

    -- Проверяем разрешён ли переход
    IF NOT EXISTS (
        SELECT 1
        FROM статусы_переходы
        WHERE ид_статус_от = OLD.ид_статус
          AND ид_статус_в = NEW.ид_статус
    ) THEN
        -- Получаем названия для ошибки
        SELECT наименование INTO v_название_старого
        FROM статусы_заказов WHERE ид_статус = OLD.ид_статус;

        SELECT наименование INTO v_название_нового
        FROM статусы_заказов WHERE ид_статус = NEW.ид_статус;

        RAISE EXCEPTION 'Прямой UPDATE: Запрещён переход "%" → "%" для груза %',
            v_название_старого, v_название_нового, OLD.ид_груз;
    END IF;

    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS валидация_перехода_статуса ON грузы;

CREATE TRIGGER валидация_перехода_статуса
    BEFORE UPDATE OF ид_статус ON грузы
    FOR EACH ROW
    WHEN (NEW.ид_статус IS DISTINCT FROM OLD.ид_статус)
    EXECUTE FUNCTION trg_валидация_перехода_статуса();

COMMENT ON TRIGGER валидация_перехода_статуса ON грузы IS 'Проверяет разрешённость перехода статуса даже при прямом UPDATE';

-- ═══════════════════════════════════════════════════════════════════════════════
-- 6. ТРИГГЕР: ЗАПИСЬ В ИСТОРИЮ ПРИ ПРЯМОМ UPDATE
-- ═══════════════════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION trg_запись_истории_статуса()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- Если статус изменился
    IF NEW.ид_статус IS DISTINCT FROM OLD.ид_статус THEN
        INSERT INTO история_статусов (
            ид_груз,
            ид_статус_старый,
            ид_статус_новый,
            дата_изменения,
            комментарий,
            ид_пользователь
        ) VALUES (
            NEW.ид_груз,
            OLD.ид_статус,
            NEW.ид_статус,
            CURRENT_TIMESTAMP,
            'Прямой UPDATE (не через функцию)',
            NULL
        );
    END IF;

    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS запись_истории_статуса ON грузы;

CREATE TRIGGER запись_истории_статуса
    AFTER UPDATE OF ид_статус ON грузы
    FOR EACH ROW
    WHEN (NEW.ид_статус IS DISTINCT FROM OLD.ид_статус)
    EXECUTE FUNCTION trg_запись_истории_статуса();

COMMENT ON TRIGGER запись_истории_статуса ON грузы IS 'Автоматически записывает изменения статуса в историю';

-- ═══════════════════════════════════════════════════════════════════════════════
-- 7. АВТОМАТИЧЕСКИЕ ПЕРЕХОДЫ: ГРУЗ_И_СРЕДСТВА → В_ПУТИ
-- ═══════════════════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION trg_авто_статус_при_назначении_транспорта()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_текущий_статус INTEGER;
    v_ид_в_пути INTEGER;
    v_ид_на_складе INTEGER;
BEGIN
    -- Получаем нужные ID статусов
    SELECT ид_статус INTO v_ид_в_пути
    FROM настройки_статусов WHERE ключ = 'в_пути';

    SELECT ид_статус INTO v_ид_на_складе
    FROM настройки_статусов WHERE ключ = 'на_складе_отправления';

    -- Получаем текущий статус груза
    SELECT ид_статус INTO v_текущий_статус
    FROM грузы WHERE ид_груз = NEW.ид_груз;

    -- Если груз на складе отправления и ему назначили транспорт → переводим "В пути"
    IF v_текущий_статус = v_ид_на_складе THEN
        PERFORM изменить_статус_груза(
            NEW.ид_груз,
            v_ид_в_пути,
            'Транспорт назначен автоматически (ID средства: ' || NEW.ид_средство || ')',
            NULL
        );
    END IF;

    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS авто_в_пути_при_назначении ON груз_и_средства;

CREATE TRIGGER авто_в_пути_при_назначении
    AFTER INSERT ON груз_и_средства
    FOR EACH ROW
    EXECUTE FUNCTION trg_авто_статус_при_назначении_транспорта();

COMMENT ON TRIGGER авто_в_пути_при_назначении ON груз_и_средства IS 'Автоматически переводит груз в статус "В пути" при назначении транспорта';

-- ═══════════════════════════════════════════════════════════════════════════════
-- 8. АВТОМАТИЧЕСКИЕ ПЕРЕХОДЫ: ГРУЗ_И_СРЕДСТВА.СТАТУС → ДОСТАВЛЕН
-- ═══════════════════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION trg_авто_доставлен_при_завершении()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_ид_доставлен INTEGER;
    v_текущий_статус INTEGER;
BEGIN
    -- Если статус перевозки изменился на "завершен"
    IF NEW.статус = 'завершен' AND OLD.статус IS DISTINCT FROM NEW.статус THEN

        -- Получаем ID статуса "доставлен"
        SELECT ид_статус INTO v_ид_доставлен
        FROM настройки_статусов WHERE ключ = 'доставлен';

        -- Получаем текущий статус груза
        SELECT ид_статус INTO v_текущий_статус
        FROM грузы WHERE ид_груз = NEW.ид_груз;

        -- Переводим в "доставлен" только если ещё не доставлен
        IF v_текущий_статус != v_ид_доставлен THEN
            PERFORM изменить_статус_груза(
                NEW.ид_груз,
                v_ид_доставлен,
                'Перевозка завершена автоматически (пройдено ' || NEW.пройдено_км || ' км)',
                NULL
            );
        END IF;
    END IF;

    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS авто_доставлен_при_завершении ON груз_и_средства;

CREATE TRIGGER авто_доставлен_при_завершении
    AFTER UPDATE OF статус ON груз_и_средства
    FOR EACH ROW
    WHEN (NEW.статус = 'завершен' AND OLD.статус IS DISTINCT FROM NEW.статус)
    EXECUTE FUNCTION trg_авто_доставлен_при_завершении();

COMMENT ON TRIGGER авто_доставлен_при_завершении ON груз_и_средства IS 'Автоматически переводит груз в "Доставлен" при завершении перевозки';

-- ═══════════════════════════════════════════════════════════════════════════════
-- 9. ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ: ПОЛУЧЕНИЕ ИСТОРИИ ГРУЗА
-- ═══════════════════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION получить_историю_груза(p_ид_груз INTEGER)
RETURNS TABLE (
    дата_изменения TIMESTAMP,
    статус_старый VARCHAR(100),
    статус_новый VARCHAR(100),
    комментарий TEXT,
    пользователь INTEGER
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        h.дата_изменения,
        s1.наименование AS статус_старый,
        s2.наименование AS статус_новый,
        h.комментарий,
        h.ид_пользователь
    FROM история_статусов h
    JOIN статусы_заказов s1 ON h.ид_статус_старый = s1.ид_статус
    JOIN статусы_заказов s2 ON h.ид_статус_новый = s2.ид_статус
    WHERE h.ид_груз = p_ид_груз
    ORDER BY h.дата_изменения DESC;
END;
$$;

COMMENT ON FUNCTION получить_историю_груза IS 'Возвращает полную историю изменений статуса груза';

-- ═══════════════════════════════════════════════════════════════════════════════
-- 10. ФУНКЦИЯ: МАССОВОЕ ОБНОВЛЕНИЕ СТАТУСОВ
-- ═══════════════════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION массовое_изменение_статуса(
    p_массив_грузов INTEGER[],
    p_ид_новый_статус INTEGER,
    p_комментарий TEXT DEFAULT NULL,
    p_ид_пользователь INTEGER DEFAULT NULL
)
RETURNS TABLE (
    ид_груз INTEGER,
    успешно BOOLEAN,
    сообщение TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_груз INTEGER;
BEGIN
    FOREACH v_груз IN ARRAY p_массив_грузов
    LOOP
        BEGIN
            PERFORM изменить_статус_груза(
                v_груз,
                p_ид_новый_статус,
                p_комментарий,
                p_ид_пользователь
            );

            RETURN QUERY SELECT v_груз, TRUE, 'Статус успешно изменён'::TEXT;
        EXCEPTION
            WHEN OTHERS THEN
                RETURN QUERY SELECT v_груз, FALSE, SQLERRM::TEXT;
        END;
    END LOOP;
END;
$$;

COMMENT ON FUNCTION массовое_изменение_статуса IS 'Изменяет статус для массива грузов с обработкой ошибок';

-- ═══════════════════════════════════════════════════════════════════════════════
-- ✅ СОЗДАНИЕ ЗАВЕРШЕНО
-- ═══════════════════════════════════════════════════════════════════════════════

SELECT 
    '✅ СОЗДАНО:' AS статус,
    (SELECT COUNT(*) FROM статусы_переходы) AS переходов,
    (SELECT COUNT(*) FROM настройки_статусов) AS настроек;

SELECT 
    '✅ ТРИГГЕРЫ:' AS тип,
    trigger_name AS имя,
    event_manipulation AS событие,
    action_timing AS время
FROM information_schema.triggers
WHERE event_object_table = 'грузы'
   OR event_object_table = 'груз_и_средства'
ORDER BY event_object_table, action_order;
